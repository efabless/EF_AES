/*
	Copyright 2023 

	Author: 

	This file is auto-generated by wrapper_gen.py


*/


`timescale			1ns/1ns
`default_nettype	none

`define		AHB_BLOCK(name, init)	always @(posedge HCLK or negedge HRESETn) if(~HRESETn) name <= init;
`define		AHB_REG(name, init)		`AHB_BLOCK(name, init) else if(ahbl_we & (last_HADDR==``name``_ADDR)) name <= HWDATA;
`define		AHB_ICR(sz)				`AHB_BLOCK(ICR_REG, sz'b0) else if(ahbl_we & (last_HADDR==ICR_REG_ADDR)) ICR_REG <= HWDATA; else ICR_REG <= sz'd0;

module SC_AES_AHBL (
	input	wire 		HCLK,
	input	wire 		HRESETn,
	input	wire [31:0]	HADDR,
	input	wire 		HWRITE,
	input	wire [1:0]	HTRANS,
	input	wire 		HREADY,
	input	wire 		HSEL,
	input	wire [2:0]	HSIZE,
	input	wire [31:0]	HWDATA,
	output	wire [31:0]	HRDATA,
	output	wire 		HREADYOUT,
	output	wire 		irq
);
	localparam[15:0] CTRL_REG_ADDR = 16'h0000;
	localparam[15:0] STATUS_REG_ADDR = 16'h0004;
	localparam[15:0] KEY0_REG_ADDR = 16'h0008;
	localparam[15:0] KEY1_REG_ADDR = 16'h000c;
	localparam[15:0] KEY2_REG_ADDR = 16'h0010;
	localparam[15:0] KEY3_REG_ADDR = 16'h0014;
	localparam[15:0] KEY4_REG_ADDR = 16'h0018;
	localparam[15:0] KEY5_REG_ADDR = 16'h001c;
	localparam[15:0] KEY6_REG_ADDR = 16'h0020;
	localparam[15:0] KEY7_REG_ADDR = 16'h0024;
	localparam[15:0] BLOCK0_REG_ADDR = 16'h0028;
	localparam[15:0] BLOCK1_REG_ADDR = 16'h002c;
	localparam[15:0] BLOCK2_REG_ADDR = 16'h0030;
	localparam[15:0] BLOCK3_REG_ADDR = 16'h0034;
	localparam[15:0] RESULT0_REG_ADDR = 16'h0038;
	localparam[15:0] RESULT1_REG_ADDR = 16'h003c;
	localparam[15:0] RESULT2_REG_ADDR = 16'h0040;
	localparam[15:0] RESULT3_REG_ADDR = 16'h0044;
	localparam[15:0] ICR_REG_ADDR = 16'h0f00;
	localparam[15:0] RIS_REG_ADDR = 16'h0f04;
	localparam[15:0] IM_REG_ADDR = 16'h0f08;
	localparam[15:0] MIS_REG_ADDR = 16'h0f0c;

	reg             last_HSEL;
	reg [31:0]      last_HADDR;
	reg             last_HWRITE;
	reg [1:0]       last_HTRANS;

	always@ (posedge HCLK) begin
		if(HREADY) begin
			last_HSEL       <= HSEL;
			last_HADDR      <= HADDR;
			last_HWRITE     <= HWRITE;
			last_HTRANS     <= HTRANS;
		end
	end

	reg	[7:0]	CTRL_REG;
	reg	[31:0]	KEY0_REG;
	reg	[31:0]	KEY1_REG;
	reg	[31:0]	KEY2_REG;
	reg	[31:0]	KEY3_REG;
	reg	[31:0]	KEY4_REG;
	reg	[31:0]	KEY5_REG;
	reg	[31:0]	KEY6_REG;
	reg	[31:0]	KEY7_REG;
	reg	[31:0]	BLOCK0_REG;
	reg	[31:0]	BLOCK1_REG;
	reg	[31:0]	BLOCK2_REG;
	reg	[31:0]	BLOCK3_REG;
	reg	[1:0]	RIS_REG;
	reg	[1:0]	ICR_REG;
	reg	[1:0]	IM_REG;

	wire		init	= CTRL_REG[0:0];
	wire		read_data	= CTRL_REG[1:1];
	wire		encdec	= CTRL_REG[2:2];
	wire		keylen	= CTRL_REG[3:3];
	wire		ready;
	wire[7:0]	STATUS_REG	= {6'b0, ready, result_valid};
	wire[255:0] key;
	assign	key[31:0]	= KEY0_REG[31:0];
	assign	key[63:32]	= KEY1_REG[31:0];
	assign	key[95:64]	= KEY2_REG[31:0];
	assign	key[127:96]	= KEY3_REG[31:0];
	assign	key[159:128]	= KEY4_REG[31:0];
	assign	key[191:160]	= KEY5_REG[31:0];
	assign	key[223:192]	= KEY6_REG[31:0];
	assign	key[255:224]	= KEY7_REG[31:0];
	wire[127:0] block;
	assign	block[31:0]	= BLOCK0_REG[31:0];
	assign	block[63:32]	= BLOCK1_REG[31:0];
	assign	block[95:64]	= BLOCK2_REG[31:0];
	assign	block[127:96]	= BLOCK3_REG[31:0];
	wire[127:0] result;
	assign	RESULT0_REG	= result[31:0];
	assign	RESULT1_REG	= result[63:32];
	assign	RESULT2_REG	= result[95:64];
	assign	RESULT3_REG	= result[127:96];
	wire		result_valid;
	wire		_VALID_FLAG_	= result_valid;
	wire		ready;
	wire		_READY_FLAG_	= ready;
	wire[1:0]	MIS_REG	= RIS_REG & IM_REG;
	wire		ahbl_valid	= last_HSEL & last_HTRANS[1];
	wire		ahbl_we	= last_HWRITE & ahbl_valid;
	wire		ahbl_re	= ~last_HWRITE & ahbl_valid;
	wire		_clk_	= HCLK;
	wire		_rst_	= ~HRESETn;

	aes_core inst_to_wrap (
		.clk(_clk_),
		.reset_n(~_rst_),
		.encdec(encdec),
		.init(init),
		.next(next),
		.ready(ready),
		.key(key),
		.keylen(keylen),
		.block(block),
		.result(result),
		.result_valid(result_valid)
	);

	`AHB_REG(CTRL_REG, 0)
	`AHB_REG(KEY0_REG, 0)
	`AHB_REG(KEY1_REG, 0)
	`AHB_REG(KEY2_REG, 0)
	`AHB_REG(KEY3_REG, 0)
	`AHB_REG(KEY4_REG, 0)
	`AHB_REG(KEY5_REG, 0)
	`AHB_REG(KEY6_REG, 0)
	`AHB_REG(KEY7_REG, 0)
	`AHB_REG(BLOCK0_REG, 0)
	`AHB_REG(BLOCK1_REG, 0)
	`AHB_REG(BLOCK2_REG, 0)
	`AHB_REG(BLOCK3_REG, 0)
	`AHB_REG(IM_REG, 0)

	`AHB_ICR(2)

	always @(posedge HCLK or negedge HRESETn)
		if(~HRESETn) RIS_REG <= 32'd0;
		else begin
			if(_VALID_FLAG_) RIS_REG[0] <= 1'b1; else if(ICR_REG[0]) RIS_REG[0] <= 1'b0;
			if(_READY_FLAG_) RIS_REG[1] <= 1'b1; else if(ICR_REG[1]) RIS_REG[1] <= 1'b0;

		end

	assign irq = |MIS_REG;

	assign	HRDATA = 
			(last_HADDR == CTRL_REG_ADDR) ? CTRL_REG :
			(last_HADDR == KEY0_REG_ADDR) ? KEY0_REG :
			(last_HADDR == KEY1_REG_ADDR) ? KEY1_REG :
			(last_HADDR == KEY2_REG_ADDR) ? KEY2_REG :
			(last_HADDR == KEY3_REG_ADDR) ? KEY3_REG :
			(last_HADDR == KEY4_REG_ADDR) ? KEY4_REG :
			(last_HADDR == KEY5_REG_ADDR) ? KEY5_REG :
			(last_HADDR == KEY6_REG_ADDR) ? KEY6_REG :
			(last_HADDR == KEY7_REG_ADDR) ? KEY7_REG :
			(last_HADDR == BLOCK0_REG_ADDR) ? BLOCK0_REG :
			(last_HADDR == BLOCK1_REG_ADDR) ? BLOCK1_REG :
			(last_HADDR == BLOCK2_REG_ADDR) ? BLOCK2_REG :
			(last_HADDR == BLOCK3_REG_ADDR) ? BLOCK3_REG :
			(last_HADDR == RIS_REG_ADDR) ? RIS_REG :
			(last_HADDR == ICR_REG_ADDR) ? ICR_REG :
			(last_HADDR == IM_REG_ADDR) ? IM_REG :
			(last_HADDR == STATUS_REG_ADDR) ? STATUS_REG :
			(last_HADDR == RESULT0_REG_ADDR) ? RESULT0_REG :
			(last_HADDR == RESULT1_REG_ADDR) ? RESULT1_REG :
			(last_HADDR == RESULT2_REG_ADDR) ? RESULT2_REG :
			(last_HADDR == RESULT3_REG_ADDR) ? RESULT3_REG :
			(last_HADDR == MIS_REG_ADDR) ? MIS_REG :
			32'hDEADBEEF;


	assign HREADYOUT = 1'b1;

endmodule
